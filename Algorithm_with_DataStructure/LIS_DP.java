//############################################################
// | cafe       | http://cafe.naver.com/dremdelover          |
// | Q&A        | https://open.kakao.com/o/gX0WnTCf          |
// | business   | ultrasuperrok@gmail.com                    |
//############################################################
public class LIS {

    // 1. 개념:
    // Longest Increasing Subsequence (LIS)는 주어진 숫자 배열에서 증가하는 부분 수열 중 가장 긴 것을 찾는 문제입니다.
    // 예를 들어, [10, 22, 9, 33, 21, 50, 41, 60, 80]의 LIS는 [10, 22, 33, 50, 60, 80]입니다.

    // 2. 입력과 출력:
    // 입력: 숫자 배열 arr[]
    // 출력: LIS의 길이

    // 3. 시간 복잡도:
    // 이 알고리즘의 시간 복잡도는 O(n^2)입니다. 
    // 이는 각 원소에 대해 이전의 모든 원소를 확인하여 LIS를 계산하기 때문입니다.

    // 4. 문제 예시:
    // - 수열 정렬: 주어진 수열을 가장 적은 수의 원소를 제거하여 오름차순으로 만드는 문제입니다.
    // - 최장 경로 찾기: 그래프에서 가장 긴 경로를 찾는 문제에서도 LIS를 응용할 수 있습니다.

    public static void main(String[] args) {
        int[] arr = {10, 22, 9, 33, 21, 50, 41, 60, 80};
        System.out.println("Length of LIS: " + lis(arr));
    }

    // 5. 세부 동작과 6, 7. 주석 및 도식화:
  static int lis(int[] arr) {
    int n = arr.length;
    int[] lis = new int[n];
    int i, j, max = 0;

    // 5. 세부 동작과 6, 7. 주석 및 도식화:
    // lis[i]는 arr[i]를 마지막으로 하는 LIS의 길이를 저장합니다.
    // 초기값은 모두 1로 설정합니다. (각 원소 자체가 LIS가 될 수 있기 때문입니다.)
    // 예: arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]
    //     lis = [1, 1, 1, 1, 1, 1, 1, 1, 1] (초기 상태)
    for (i = 0; i < n; i++) {
        lis[i] = 1;
    }

    // 동적 프로그래밍을 사용하여 LIS를 계산합니다.
    // lis[i]는 arr[j] < arr[i]이고, j < i인 lis[j] + 1과 lis[i] 중 최대값으로 설정됩니다.
    // 이는 arr[i]가 arr[j] 다음에 올 수 있으며, 이로 인해 생성되는 새로운 IS의 길이가 기존의 lis[i]보다 길 경우 업데이트가 필요하다는 것을 의미합니다.
    // 예: i=3, j=1일 때,
    //     arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]
    //     lis = [1, 1, 1, 3, 1, 1, 1, 1, 1] (arr[3]는 arr[1] 다음에 올 수 있으므로 lis[3] = lis[1] + 1)
    for (i = 1; i < n; i++) {
        for (j = 0; j < i; j++) {
            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) {
                lis[i] = lis[j] + 1;
            }
        }
    }

    // lis[] 배열에서 가장 큰 값을 찾아 LIS의 길이를 결정합니다.
    // 예: arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]
    //     lis = [1, 2, 1, 3, 2, 4, 4, 5, 6] (최종 상태)
    //     max = 6 (LIS의 길이)
    for (i = 0; i < n; i++) {
        if (max < lis[i]) {
            max = lis[i];
        }
    }
    return max;

    /*
    1. 초기화:
   - `lis[]` 배열을 생성하고, 모든 원소를 1로 초기화합니다. 이 배열은 `lis[i]`가 `arr[i]`를 마지막 원소로 가지는 LIS의 길이를 저장합니다.
     - `arr[] = [10, 22, 9, 33, 21]`
     - `lis[] = [1, 1, 1, 1, 1]`

    2. LIS 길이 계산:
    - arr[1] (22)을 처리하는 과정:
        - 현재 원소는 22입니다. 이전 원소와 비교하여 현재 원소보다 작은 원소가 있는지 확인합니다. 이전 원소는 10입니다.
        - 현재 원소(22)보다 이전 원소(10)가 작기 때문에, 이전 원소(10)의 LIS 길이에 1을 더한 값(1+1=2)을 현재 원소의 LIS 길이 후보로 고려합니다.
        - `lis[1]`을 2로 업데이트합니다.
        - `lis[] = [1, 2, 1, 1, 1]`

    - arr[2] (9)을 처리하는 과정:
        - 현재 원소는 9입니다. 이전 원소와 비교하여 현재 원소보다 작은 원소가 있는지 확인합니다. 이전 원소는 22입니다.
        - 현재 원소(9)보다 이전 원소(22)가 크기 때문에, 현재 원소(9)는 자체적으로 길이 1짜리 LIS가 됩니다.
        - `lis[2]`는 1로 유지됩니다.
        - `lis[] = [1, 2, 1, 1, 1]`

    - arr[3] (33)을 처리하는 과정:
        - 현재 원소는 33입니다. 이전 원소와 비교하여 현재 원소보다 작은 원소가 있는지 확인합니다. 이전 원소는 9, 22, 10입니다.
        - 현재 원소(33)보다 작은 원소가 있는 경우, 그 중 가장 큰 LIS 길이를 찾아서 현재 원소의 LIS 길이 후보로 고려합니다.
        - 이전 원소(22)의 LIS 길이는 2이고, 이것이 현재 원소(33)의 LIS 길이 후보가 됩니다.
        - `lis[3]`을 2로 업데이트합니다.
        - `lis[] = [1, 2, 1, 2, 1]`

    - arr[4] (21)을 처리하는 과정:
        - 현재 원소는 21입니다. 이전 원소와 비교하여 현재 원소보다 작은 원소가 있는지 확인합니다. 이전 원소는 9, 22, 10, 33입니다.
        - 현재 원소(21)보다 작은 원소가 있는 경우, 그 중 가장 큰 LIS 길이를 찾아서 현재 원소의 LIS 길이 후보로 고려합니다.
        - 이전 원소(22)의 LIS 길이는 2이고, 이것이 현재 원소(21)의 LIS 길이 후보가 됩니다.
        - `lis[4]`을 2로 업데이트합니다.
        - `lis[] = [1, 2, 1, 2, 2]`

    3. 최종 결과:
    - 이 과정을 모든 원소에 대해 반복하면, `lis[]` 배열에는 각 원소를 마지막으로 하는 LIS의 길이가 저장됩니다.
        - `arr[] = [10, 22, 9, 33, 21]`
        - 최종 `lis[] = [1, 2, 1, 2, 2]` (각 원소를 마지막으로 하는 LIS의 길이가 계산됨)
    */
    }
}
